# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QGisFoncierDialog
                                 A QGIS plugin
 Import photos
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-07-25
        git sha              : $Format:%H$
        copyright            : (C) 2019 by stephanie criado
        email                : stephanie.criado@cerema.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *


from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, QFileInfo
from PyQt5.QtGui import QIcon, QPixmap
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from qgis.core import QgsProject, QgsApplication, QgsProcessingFeedback, QgsVectorLayer, QgsDataSourceUri, QgsSettings
from qgis.core import QgsRendererRangeLabelFormat, QgsGraduatedSymbolRenderer, QgsGradientColorRamp, QgsPalLayerSettings, QgsTextFormat
from qgis.core import QgsTextBufferSettings, QgsRuleBasedLabeling, QgsVectorLayerSimpleLabeling, QgsSymbol, QgsSimpleFillSymbolLayer
from qgis.core import QgsRendererCategory, QgsCategorizedSymbolRenderer, QgsFeatureRequest, QgsCoordinateReferenceSystem, QgsVectorLayerExporter
from qgis.core import QgsVectorFileWriter, QgsAction, QgsExpressionContext
from qgis.utils import iface
from qgis.gui import QgsMapCanvas

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
import os.path
import os,sys,psycopg2
from psycopg2.extensions import AsIs
from datetime import datetime, date
from time import localtime, gmtime, strftime
import csv,shutil,re
import processing
from .variables import *

psycopg2.autocommit = True

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'qgis_foncier.ui'))


class QGisFoncierDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(QGisFoncierDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)      
        self.initialisation_couches_agg = True
        
        # Remplissage des champs des valeurs du serveur Postgres par défaut à partir des information de QGIS.ini
        mDic_Init = self.returnParamServPG()
        self.mDic_Init = mDic_Init
        
        self.lineAdrServ.setText(mDic_Init["AdrServPG"])
        self.linePortServ.setText(mDic_Init["port"])
        self.lineUserServ.setText(mDic_Init["user"]) 
        self.lineMdpServ.setText(mDic_Init["mdp"])
        self.lineBaseDonnees.setText(mDic_Init["NomBD"])
        
        schemaProd=[]
        if mDic_Init["schemaProd"]!="":            
            schemaProd.append(mDic_Init["schemaProd"])
            self.comboBoxChoixSchemaProd.clear()
            self.comboBoxChoixSchemaProd.addItems(schemaProd)
            self.comboBoxChoixSchemaProd.setCurrentIndex(0)
        
        schemaBDTopo=[]
        if mDic_Init["schemaBDTopo"]!="":            
            schemaBDTopo.append(mDic_Init["schemaBDTopo"])
            self.comboBoxChoixSchemaBDTopo.clear()
            self.comboBoxChoixSchemaBDTopo.addItems(schemaBDTopo)
            self.comboBoxChoixSchemaBDTopo.setCurrentIndex(0)

        schemaFFDep=[]
        if mDic_Init["schemaFFDep"]!="":            
            schemaFFDep.append(mDic_Init["schemaFFDep"])
            self.comboBoxChoixSchemaFFDep.clear()
            self.comboBoxChoixSchemaFFDep.addItems(schemaFFDep)
            self.comboBoxChoixSchemaFFDep.setCurrentIndex(0)
            
        schemaData=[]
        if mDic_Init["schemaData"]!="":            
            schemaData.append(mDic_Init["schemaData"])
            self.comboBoxChoixSchemaData.clear()
            self.comboBoxChoixSchemaData.addItems(schemaData)
            self.comboBoxChoixSchemaData.setCurrentIndex(0)

        tabPLU=[]
        if mDic_Init["tabPLU"]!="":            
            tabPLU.append(mDic_Init["tabPLU"])
            self.comboBoxChoixTabPlu.clear()
            self.comboBoxChoixTabPlu.addItems(tabPLU)
            self.comboBoxChoixTabPlu.setCurrentIndex(0)

        tabEnvurb=[]
        if mDic_Init["tabEnvurb"]!="":            
            tabEnvurb.append(mDic_Init["tabEnvurb"])
            self.comboBoxChoixTabEnvurb.clear()
            self.comboBoxChoixTabEnvurb.addItems(tabEnvurb)
            self.comboBoxChoixTabEnvurb.setCurrentIndex(0)

        tabCommune=[]
        if mDic_Init["tabCommune"]!="":            
            tabCommune.append(mDic_Init["tabCommune"])
            self.comboBoxChoixTabCommune.clear()
            self.comboBoxChoixTabCommune.addItems(tabCommune)
            self.comboBoxChoixTabCommune.setCurrentIndex(0)

        tabBati=[]
        if mDic_Init["tabBati"]!="":            
            tabBati.append(mDic_Init["tabBati"])
            self.comboBoxChoixTabBati.clear()
            self.comboBoxChoixTabBati.addItems(tabBati)
            self.comboBoxChoixTabBati.setCurrentIndex(0)

        tabRoute=[]
        if mDic_Init["tabRoute"]!="":            
            tabRoute.append(mDic_Init["tabRoute"])
            self.comboBoxChoixTabRoute.clear()
            self.comboBoxChoixTabRoute.addItems(tabRoute)
            self.comboBoxChoixTabRoute.setCurrentIndex(0)

        tabTup=[]
        if mDic_Init["tabTup"]!="":            
            tabTup.append(mDic_Init["tabTup"])
            self.comboBoxChoixTabTup.clear()
            self.comboBoxChoixTabTup.addItems(tabTup)
            self.comboBoxChoixTabTup.setCurrentIndex(0)            

        geomTup=[]
        if mDic_Init["geomTup"]!="":            
            geomTup.append(mDic_Init["geomTup"])
            self.comboBoxChoixGeomTup.clear()
            self.comboBoxChoixGeomTup.addItems(geomTup)
            self.comboBoxChoixGeomTup.setCurrentIndex(0)   
            
        self.lineDossierSortie.setText(mDic_Init["dossierSortie"])
        
        self.comboBoxChoixSchemaData.currentIndexChanged.connect(self.QGISIniSave)
        self.comboBoxChoixSchemaBDTopo.currentIndexChanged.connect(self.QGISIniSave)
        self.comboBoxChoixSchemaFFDep.currentIndexChanged.connect(self.QGISIniSave)
        self.comboBoxChoixSchemaProd.currentIndexChanged.connect(self.QGISIniSave)
        self.comboBoxChoixTabPlu.currentIndexChanged.connect(self.QGISIniSave)
        self.comboBoxChoixTabEnvurb.currentIndexChanged.connect(self.QGISIniSave)
        self.comboBoxChoixTabCommune.currentIndexChanged.connect(self.QGISIniSave)
        self.comboBoxChoixTabBati.currentIndexChanged.connect(self.QGISIniSave)
        self.comboBoxChoixTabRoute.currentIndexChanged.connect(self.QGISIniSave)
        self.comboBoxChoixTabTup.currentIndexChanged.connect(self.QGISIniSave)
        self.comboBoxChoixGeomTup.currentIndexChanged.connect(self.QGISIniSave)
                
        self.boutonVoirDossierSortie.clicked.connect(self.SelectionDossierSortie)
        
        # Remplissage des champs des valeurs des paramètres de traitement
        self.lineSurfMinPolyEnvUrb.setText(surf_min_zone)
        self.lineSurfMinTrousEnvUrb.setText(surf_comblement)
        self.lineSurfMinBat.setText(surfminbat)
        self.lineTauxSurfInterUFEnvUrb.setText(taux_surface)
        self.lineSurfMinInterUFEnvUrb.setText(surfminuf)
        self.lineLargMin.setText(largeur_min)
        self.lineLargMinAcces.setText(larg_acces)
        self.lineEspReserveDense.setText(reserve_dense)
        self.lineSurfMinObjDense.setText(surf_dense)
        self.lineTauxConvexhull.setText(taux_convexhull)
        
        # Alimentation de la combobox "Région"
        self.alimReg()
        self.comboBoxChoixReg.currentIndexChanged.connect(self.alimDep)
        self.comboBoxChoixReg.currentIndexChanged.connect(self.reinitBoxCom)
        
        # Remplissage de la combobox choix département        
        self.comboBoxChoixDep.currentIndexChanged.connect(self.alimEPCI)        
        #self.comboBoxChoixDep.currentIndexChanged.connect(self.AfficheCommunes)
        self.boutonVoirComDep.clicked.connect(self.AfficheCommunesDep)

        # Remplissage de la combobox choix EPCI                    
        #self.comboBoxChoixEPCI.currentIndexChanged.connect(self.AfficheCommunesEPCI)
        self.boutonVoirComEPCI.clicked.connect(self.AfficheCommunesEPCI)
        
        ## CheckBox tout sélectionner ou tout délectionner
        self.checkBoxSelectAll.clicked.connect(self.selectAll)
        
        # Bouton ajout communes
        self.boutonAjoutCom.clicked.connect(self.AjoutCommunes)
        
        # Bouton suppression communes
        self.boutonSupprCom.clicked.connect(self.SuppCommunes)
        
        # Bouton Vider la sélection
        self.boutonViderSelec.clicked.connect(self.viderSelection)
        
        # Bouton exécution du traitement
        self.boutonLanceTraitement.clicked.connect(self.verifCouches)
        
        # Bouton de vérification des paramètres du serveur Postgres
        self.boutonMajServ.clicked.connect(self.CheckConnPG)
        
        # Bouton de nettoyage de la base Postgres (suppression des tables du schéma de travail)
        self.boutonNettoyBase.clicked.connect(self.NettoyerBase)
        
        # Ouverture fichier de notice
        self.boutonAfficheNotice.clicked.connect(self.AfficheNotice)
                
        #import des données
        self.boutonVoirFicFF.clicked.connect(self.SelectionFicFF)
        self.boutonImportFF.clicked.connect(self.ImportFF)
        self.boutonVoirFicRoutes.clicked.connect(self.SelectionFicRoutes)
        self.boutonImportRoutes.clicked.connect(self.ImportRoutes)
        self.boutonVoirFicCom.clicked.connect(self.SelectionFicCom)
        
        self.boutonImportCom.clicked.connect(self.ImportCom)
        
        
        self.boutonVoirFicBat.clicked.connect(self.SelectionFicBat)
        self.boutonImportBat.clicked.connect(self.ImportBat)
        self.boutonVoirFicPLU.clicked.connect(self.SelectionFicPLU)
        self.boutonImportPLU.clicked.connect(self.ImportPLU)
        self.boutonVoirFicEnvUrb.clicked.connect(self.SelectionFicEnvUrb)
        self.boutonImportEnvUrb.clicked.connect(self.ImportEnvUrb)
        
        #import de la couche d'exclusion
        self.boutonVoirExclusion.clicked.connect(self.SelectionFicExclusion)
        self.boutonImportExclusion.clicked.connect(self.ImportExclusion)
        
        #Copie fonctions SQL
        self.boutonCopieSQL.clicked.connect(self.ImportFonctionsScripts)

        #barre de progression
        self.progressBar.hide()
        
        #Création dossier sortie foncier_mutable et dv3f
        try:
            os.mkdir(dossierSortie)
            
        except:
            pass

    # Remplissage de la combobox choix Région
    def alimReg(self):
        listeReg = os.path.dirname(__file__)+"/csv/liste_reg.csv"                 
        
        listchoixReg = []
        
        with open (r""+ listeReg +"", newline='') as f:
            readerDep = csv.reader(f, delimiter=';')
            for row in readerDep:
                listchoixReg.append(row[0])
                # Ajout d'items depuis la liste
                # Aucune valeur par défaut
                self.comboBoxChoixReg.clear()
                self.comboBoxChoixReg.addItems(listchoixReg)
                self.comboBoxChoixReg.setCurrentIndex(0)
                    
    # Remplissage de la combobox choix Département
    def alimDep(self):
        try:
            # Récupération des paramètres de connexion au serveur PG
            conn = psycopg2.connect(self.ConnectServer())
            cur = conn.cursor()

            sqlstr1 = "SELECT insee_dep || ' - ' || nom FROM public.departement WHERE insee_reg = '"+ self.comboBoxChoixReg.currentText().split(" - ")[0] +"' order by insee_dep"
            cur.execute(sqlstr1)
            listchoixdep = cur.fetchall()                                        
            self.comboBoxChoixDep.clear() # Aucune valeur dep par défaut
            for i in listchoixdep:
                self.comboBoxChoixDep.addItems(i)
                self.comboBoxChoixDep.setCurrentIndex(0)
        except:
            pass

    # réinitialisation de la fenêtre d'affichage des communes
    def reinitBoxCom(self):
        listeCom=[]
        self.ListeCommunes.clear()
        self.ListeCommunesSelec.clear()
        self.lineNbComSelec.clear()
        self.lineNbCom.clear()                    
        self.ListeCommunes.addItems(listeCom)

    # Remplissage de la combobox choix EPCI
    def alimEPCI(self):
        try:
            # Récupération des paramètres de connexion au serveur PG
            conn = psycopg2.connect(self.ConnectServer())        
            cur = conn.cursor()

            sqlstr1 = "SELECT code_siren || ' - ' || nom FROM public.epci WHERE insee_dep like '%"+ self.comboBoxChoixDep.currentText().split(" - ")[0] +"%' order by insee_dep"
            cur.execute(sqlstr1)
            listeEPCI = cur.fetchall()
            # Aucune valeur par défaut 
            self.comboBoxChoixEPCI.clear()        
            for i in listeEPCI:
                # Ajout d'items depuis la liste
                self.comboBoxChoixEPCI.addItems(i)
                self.comboBoxChoixEPCI.setCurrentIndex(0)   
        except:
            pass
            
    # Import des couches departement et epci dans la base (alimentation des combobox depatrement et EPCI)
    def importDeptEPCIGPKG(self):    
        AdrServPG=self.lineAdrServ.text()
        port=self.linePortServ.text()
        user=self.lineUserServ.text()
        mdp=self.lineMdpServ.text()
        NomBD=self.lineBaseDonnees.text()
        
        # Récupération des paramètres de connexion au serveur PG
        conn = psycopg2.connect(self.ConnectServer())
        cur = conn.cursor()

        #Chargement des couches Département et EPCI        
        deptEPCI=os.path.dirname(__file__)+"/csv/dept_epci.gpkg"
        
        #effacement des tables département et EPCI au préalable
        sqlstr1 = "DROP TABLE IF EXISTS public.departement;"
        cur.execute(sqlstr1)
        conn.commit()
        sqlstr2 = "DROP TABLE IF EXISTS public.epci;"
        cur.execute(sqlstr2)
        conn.commit()
        
        for layer in ('departement','epci'):
            gpkg_layer = deptEPCI + "|layername="+layer
            vlayer = QgsVectorLayer(gpkg_layer, layer, "ogr")
            con_string = "dbname='"+NomBD+"' host='"+AdrServPG+"' port='"+port+"' user='"+user+"' password='"+mdp+"' key=my_id schema=public table="+layer
            err = QgsVectorLayerExporter.exportLayer(vlayer, con_string, 'postgres', QgsCoordinateReferenceSystem(2154), False)

        
    # Fonction afficher les communes du département
    def AfficheCommunesDep(self):
        
        if self.comboBoxChoixDep.currentIndex()!=-1:
            # Récupération des paramètres de connexion au serveur PG
            conn = psycopg2.connect(self.ConnectServer())
            cur = conn.cursor()
            
            schemaBDTopo = self.comboBoxChoixSchemaBDTopo.currentText()
            tabCommune = self.comboBoxChoixTabCommune.currentText()
            #tabTup = self.comboBoxChoixTabTup.currentText()
            #depTup = tabTup[1:3]

            dep=self.comboBoxChoixDep.currentText().split(" - ")[0]
            
            #print (depTup + " " + dep)

            #test sur table TUP
            try:
                reqsql = "SELECT insee_com,nom FROM "+schemaBDTopo+"."+tabCommune+" WHERE insee_dep='"+dep+"' ORDER BY insee_com;"
                cur.execute(reqsql)
                lcommunes = cur.fetchall()
                conn.close()

                listeCom=[]
                if len(lcommunes)==0:
                    listeCom.append("Pas de données source")
                    self.ListeCommunes.clear()
                    self.ListeCommunesSelec.clear()
                    self.lineNbComSelec.clear()
                    self.lineNbCom.clear()                    
                    self.ListeCommunes.addItems(listeCom)
                else:
                    for com in lcommunes:
                        listeCom.append(com[0]+"  "+com[1])
                        
                    self.ListeCommunes.clear()
                    self.ListeCommunesSelec.clear()
                    self.lineNbComSelec.clear()
                    self.lineNbCom.clear()
                    self.ListeCommunes.addItems(listeCom)
                    self.lineNbCom.setText(str(len(listeCom)))
                    self.checkBoxSelectAll.setChecked(False)                
            except:
                
                pass             
        else:
            pass

    # Fonction afficher les communes du département
    def AfficheCommunesEPCI(self):
        
        if self.comboBoxChoixEPCI.currentIndex()!=-1:
            # Récupération des paramètres de connexion au serveur PG
            conn = psycopg2.connect(self.ConnectServer())
            cur = conn.cursor()
            
            schemaBDTopo = self.comboBoxChoixSchemaBDTopo.currentText()
            tabCommune = self.comboBoxChoixTabCommune.currentText()

            epci=self.comboBoxChoixEPCI.currentText().split(" - ")[0]
            
            try:
                reqsql = "SELECT insee_com,nom FROM "+schemaBDTopo+"."+tabCommune+" WHERE siren_epci='"+epci+"' ORDER BY insee_com;"
                cur.execute(reqsql)
                lcommunes = cur.fetchall()
                conn.close()

                listeCom=[]
                if len(lcommunes)==0:
                    listeCom.append("Pas de données source")
                    self.ListeCommunes.clear()
                    self.ListeCommunesSelec.clear()
                    self.lineNbComSelec.clear()
                    self.lineNbCom.clear()                    
                    self.ListeCommunes.addItems(listeCom)
                else:
                    for com in lcommunes:
                        listeCom.append(com[0]+"  "+com[1])
                        
                    self.ListeCommunes.clear()
                    self.ListeCommunesSelec.clear()
                    self.lineNbComSelec.clear()
                    self.lineNbCom.clear()
                    self.ListeCommunes.addItems(listeCom)
                    self.lineNbCom.setText(str(len(listeCom)))
                    self.checkBoxSelectAll.setChecked(False)                
            except:
                
                pass             
        else:
            pass
            
    # Fonction ajouter des communes
    def AjoutCommunes(self):
        nbSelecListeCom = self.ListeCommunesSelec.count()

        if nbSelecListeCom > 0 :

            itemsListeCom = []
            for index in range(self.ListeCommunesSelec.count()):
                itemsListeCom.append(self.ListeCommunesSelec.item(index))
            labelsListeCom = [i.text() for i in itemsListeCom]

            itemsCommunes=[]
            for value in self.ListeCommunes.selectedItems():
                if str(value.text()) not in labelsListeCom:
                    itemsCommunes.insert(-1,str(value.text()))
                else:
                    pass

            self.ListeCommunesSelec.addItems(itemsCommunes)

        else :
            itemsCommunes=[]
            for value in self.ListeCommunes.selectedItems():
                itemsCommunes.insert(0,str(value.text()))
            self.ListeCommunesSelec.addItems(itemsCommunes)
            
        self.lineNbComSelec.setText(str(self.ListeCommunesSelec.count()))

    # Fonction supprimer des communes
    def SuppCommunes(self):
        for value in self.ListeCommunesSelec.selectedItems():
            self.ListeCommunesSelec.takeItem(self.ListeCommunesSelec.row(value))
        
        self.lineNbComSelec.setText(str(self.ListeCommunesSelec.count()))

    # Fonction Vider la sélection
    def viderSelection(self):
        self.ListeCommunesSelec.clear()
        self.lineNbComSelec.setText(str(self.ListeCommunesSelec.count()))
        
    #lancer une requête
    def execFicSql(self,fichier,param=''):
        # Récupération des paramètres de connexion au serveur PG
        AdrServPG=self.lineAdrServ.text()
        port=self.linePortServ.text()
        user=self.lineUserServ.text()
        mdp=self.lineMdpServ.text()
        NomBD=self.lineBaseDonnees.text()

        str_rep_python = sys.base_prefix  # ajout MM
        str_rep_base = os.path.join(os.path.split(os.path.split(str_rep_python)[0])[0], 'bin')  # ajout MM

        os.environ['PGPASSWORD'] = mdp
        os.environ['PGCLIENTENCODING'] = 'UTF-8'
        psqlPath = os.path.join(str_rep_base, "psql")  # modif MM
        #print (psqlPath)
        cmd = '"' + psqlPath + '"  -w -h ' + AdrServPG + ' -p ' + port + ' -U ' + user + ' -d ' + NomBD + ' -q -f ' + fichier+param

        try:
            os.system(cmd)
        except:
            pass
    
    # creer un repertoire s'il n'existe pas
    def CreerDossier(self,dir):
        try:
            os.mkdir(dir)
            #print('creation du repertoire de sortie '+dir)
        except:
            pass
            #print('repertoire '+dir+'existe deja')
            
    # gestion log
    def initLog(self,dossier):
        global table_log,sql_logfile
        try:
            dir_out=dossier+os.sep+"out_"+self.tps()[0:17].replace(":","").replace("-","_")+os.sep
            self.CreerDossier(dir_out)
            table_log=dir_out+os.sep+'log.txt'
            ff=open(table_log,'w')
            ff.close()
            
            sql_logfile=dir_out+os.sep+'logsql.txt'
            ff1=open(sql_logfile,'w')
            ff1.close()
            
            #print (' repertoire de sortie par défaut: '+dir_out)
        except:
            QMessageBox.critical(self,"Erreur","Veuillez vérifier le chemin d'accès au dossier de sortie (onglet Paramètres serveur PG) !!!")
       
    def ajoutLog(self,text,retour=True):
        global table_log
        try:
            logfile = open(table_log, 'a')
            ret='--'+self.tps()+' > '+text+'\n--\n'
            logfile.write(ret)
            logfile.close()
        except:
            QMessageBox.critical(self,"Erreur","Veuillez vérifier le chemin d'accès au dossier de sortie (onglet Paramètres serveur PG) !!!")
        
    def tps(self):
        return(strftime("%Y%m%d-%H:%M:%S", localtime()))
        print(tps())

    def verifCouches(self):
    
        tabCommune = self.comboBoxChoixTabCommune.currentText()
        tabRoute = self.comboBoxChoixTabRoute.currentText()
        tabBati = self.comboBoxChoixTabBati.currentText()
        tabPlu = self.comboBoxChoixTabPlu.currentText()
        tabEnvurb = self.comboBoxChoixTabEnvurb.currentText()
        tabTup = self.comboBoxChoixTabTup.currentText()
        
        err=0
        err2=0        
        
        if len(tabCommune)==0:
            QMessageBox.critical(self,"Erreur","Veuillez définir la couche des communes dans l'onglet Paramètres serveur PG !!!")
            err=1
        if len(tabRoute)==0:
            QMessageBox.critical(self,"Erreur","Veuillez définir la couche des routes dans l'onglet Paramètres serveur PG !!!")
            err=1
        if len(tabBati)==0:
            QMessageBox.critical(self,"Erreur","Veuillez définir la couche des bâtiments dans l'onglet Paramètres serveur PG !!!")
            err=1
        if len(tabEnvurb)==0:
            QMessageBox.critical(self,"Erreur","Veuillez définir la couche des enveloppes urbaines dans l'onglet Paramètres serveur PG !!!")
            err=1
        if len(tabPlu)==0:
            QMessageBox.critical(self,"Erreur","Veuillez définir la couche des PLU dans l'onglet Paramètres serveur PG !!!")
            err=1
        if len(tabTup)==0:
            QMessageBox.critical(self,"Erreur","Veuillez définir la couche des TUP dans l'onglet Paramètres serveur PG !!!")
            err=1
        
        nbComSelect=self.lineNbComSelec.text()
        if len(nbComSelect)==0:
            QMessageBox.critical(self,"Erreur","Aucune commune sélectionnée !!!")
            err2=1
            
        if err==0 and err2==0:
            self.ExecTraitement()
        else:
            pass
            
                
    # Fonction Exécution du traitement
    def ExecTraitement(self):
        global sql_logfile
        
        mdp=self.lineMdpServ.text()
        # Récupération des paramètres de connexion au serveur PG
        conn = psycopg2.connect(self.ConnectServer())
        cur = conn.cursor()
        
        # Récupération des noms des tables PG pour le traitement              
        schemaProd=self.comboBoxChoixSchemaProd.currentText()
        schemaBDTopo=self.comboBoxChoixSchemaBDTopo.currentText()
        schemaFFDep=self.comboBoxChoixSchemaFFDep.currentText()
        schemaData=self.comboBoxChoixSchemaData.currentText()
        tabRoute = self.comboBoxChoixTabRoute.currentText()
        tabCommune = self.comboBoxChoixTabCommune.currentText()
        tabBati = self.comboBoxChoixTabBati.currentText()
        tabPLU = self.comboBoxChoixTabPlu.currentText()
        tabEnvurb = self.comboBoxChoixTabEnvurb.currentText()
        tabTup = self.comboBoxChoixTabTup.currentText()
        geomTup = self.comboBoxChoixGeomTup.currentText()
        
        dossierSortie = self.lineDossierSortie.text()
                
        str_rep_python = sys.base_prefix  # ajout MM
        str_rep_base = os.path.join(os.path.split(os.path.split(str_rep_python)[0])[0], 'bin')  # ajout MM

        os.environ['PGPASSWORD'] = mdp
        os.environ['PGCLIENTENCODING'] = 'UTF-8'
        psqlPath = os.path.join(str_rep_base, "psql")  # modif MM
        
        # Récupération des paramètres de traitement
        surf_min_zone=self.lineSurfMinPolyEnvUrb.text()
        surf_comblement=self.lineSurfMinTrousEnvUrb.text()
        surfminbat=self.lineSurfMinBat.text()
        taux_surface=self.lineTauxSurfInterUFEnvUrb.text()
        surfminuf=self.lineSurfMinInterUFEnvUrb.text()
        largeur_min=self.lineLargMin.text()
        larg_acces=self.lineLargMinAcces.text()
        reserve_dense=self.lineEspReserveDense.text()
        reserve_groupee=str(float(reserve_dense)*1.5)
        reserve_diffuse=str(float(reserve_dense)*2.5)
        reserve_isolee=str(float(reserve_dense)*3.5)
        surf_dense=self.lineSurfMinObjDense.text()
        surf_groupee=str(float(surf_dense)*1.66)
        surf_diffuse=str(float(surf_dense)*3.33)
        taux_convexhull=self.lineTauxConvexhull.text()
        
        dep=self.comboBoxChoixDep.currentText().split("  ")[0]
        
        val_progression=0 
        
        #init log
        try:
            os.mkdir(dossier_log)
        except:
            pass

        try:
            self.initLog(dossier_log)
        except:
            pass
            

        reqsql = "SELECT routine_name FROM information_schema.routines where routine_name like '__1_envurb%' and routine_schema='" + schemaProd +"' "
        cur.execute(reqsql)
        res = cur.fetchall()
        
        if res == []:
            QMessageBox.critical(self,"Attention","Veuillez importer les fonctions de traitement depuis l'onglet 'Paramètres serveur PG' !!!")
            
        else:
        
            reply = QMessageBox.question(self, 'Confirmation','Voulez-vous lancer le traitement sur les communes sélectionnées ?', QMessageBox.Yes, QMessageBox.No)

            if reply == QMessageBox.Yes:
                compteur=0
                items = []
                for index in range(self.ListeCommunesSelec.count()):
                    items.append(self.ListeCommunesSelec.item(index))
                com = [i.text() for i in items]
                for element in com:
                    compteur += 1
                    idcom=element[:5].lower()
                    idcom2="'"+idcom.upper()+"'"
                    #print(idcom + '  ' + str(self.ListeCommunesSelec.count()) + '  ' + element)
   
                    if self.checkBoxExclusion.isChecked()==1:
                        try:
                            # test présence couche exclusion
                            cur.execute("SELECT * FROM "+schemaData+".zones_exclusion limit 1;")
                            conn.commit()
                            cur.execute("SELECT "+schemaProd+".__1_envurb_exclusion('"+schemaProd+"','"+schemaData+"','"+schemaBDTopo+"','"+idcom+"','"+tabCommune+"','"+tabEnvurb+"','"+tabPLU+"',"+surf_min_zone+","+surf_comblement+");")
                            conn.commit()
                            self.execScriptSQL(schemaProd,schemaData,schemaBDTopo,idcom,tabCommune,tabEnvurb,tabPLU,surf_min_zone,surf_comblement,schemaFFDep,tabTup,geomTup,tabBati,surfminbat,reserve_dense,reserve_groupe,reserve_diffus,reserve_isole,taux_surface,surfminuf,largeur_min,taux_convexhull,surf_dense,tabRoute,larg_acces)
                            
                            self.productionCarte(idcom,dossierSortie,schemaProd,com)
                            
                            #message de fin de traitement
                            self.progressBar.hide()
                            if compteur == len(com):
                                QMessageBox.information(self,"Traitement","Traitement terminé !!!")
                        
                        except:
                            QMessageBox.critical(self,"Attention","Aucune couche de zonages d''exclusion n'est présente dans la base !!!")
                            pass
                    else:
                        cur.execute("SELECT "+schemaProd+".__1_envurb('"+schemaProd+"','"+schemaData+"','"+schemaBDTopo+"','"+idcom+"','"+tabCommune+"','"+tabEnvurb+"','"+tabPLU+"',"+surf_min_zone+","+surf_comblement+");")
                        conn.commit()
                        self.execScriptSQL(schemaProd,schemaData,schemaBDTopo,idcom,tabCommune,tabEnvurb,tabPLU,surf_min_zone,surf_comblement,schemaFFDep,tabTup,geomTup,tabBati,surfminbat,reserve_dense,reserve_groupe,reserve_diffus,reserve_isole,taux_surface,surfminuf,largeur_min,taux_convexhull,surf_dense,tabRoute,larg_acces) 
                        
                        self.productionCarte(idcom,dossierSortie,schemaProd,com)                    

                        #message de fin de traitement
                        self.progressBar.hide()
                        if compteur == len(com):
                            QMessageBox.information(self,"Traitement","Traitement terminé !!!")

            else:
                pass      

    # exécution des fonctions SQL
    def execScriptSQL(self,schemaProd,schemaData,schemaBDTopo,idcom,tabCommune,tabEnvurb,tabPLU,surf_min_zone,surf_comblement,schemaFFDep,tabTup,geomTup,tabBati,surfminbat,reserve_dense,reserve_groupe,reserve_diffus,reserve_isole,taux_surface,surfminuf,largeur_min,taux_convexhull,surf_dense,tabRoute,larg_acces):

        # Récupération des paramètres de connexion au serveur PG
        conn = psycopg2.connect(self.ConnectServer())
        cur = conn.cursor()
        
        self.progressBar.show()
        val_progression=10        
        self.progressBar.setValue(val_progression) 
        
        req="SELECT "+schemaProd+".__2_batiment_densite_urbaine('"+schemaProd+"','"+schemaBDTopo+"','"+schemaFFDep+"','"+tabTup+"','"+geomTup+"','"+idcom+"','"+tabCommune+"','"+tabBati+"',"+surfminbat+","+surf_comblement+","+reserve_dense+","+reserve_groupe+","+reserve_diffus+","+reserve_isole+");"
        print(req)

        cur.execute(req)
        conn.commit()
        val_progression=30        
        self.progressBar.setValue(val_progression) 

        req="SELECT "+schemaProd+".__3_uf_non_bati_lot1('"+schemaProd+"','"+idcom+"',"+taux_surface+","+surfminuf+","+largeur_min+","+taux_convexhull+","+surf_dense+");"
        cur.execute(req)
        conn.commit()
        val_progression=35        
        self.progressBar.setValue(val_progression) 

        req="SELECT "+schemaProd+".__4_uf_espace_residuel_lots2et3('"+schemaProd+"','"+idcom+"',"+largeur_min+","+surf_dense+","+taux_convexhull+");"
        cur.execute(req)
        conn.commit()
        val_progression=40        
        self.progressBar.setValue(val_progression) 
        
        req="SELECT "+schemaProd+".__5_accessibilite('"+schemaProd+"','"+schemaBDTopo+"','"+idcom+"','"+tabRoute+"');"
        cur.execute(req)
        conn.commit()
        val_progression=70       
        self.progressBar.setValue(val_progression)           

        req="SELECT "+schemaProd+".__6_acces_indirect('"+schemaProd+"','"+idcom+"',"+larg_acces+");"
        cur.execute(req)
        conn.commit()
        val_progression=72        
        self.progressBar.setValue(val_progression)        
        
        req="SELECT "+schemaProd+".__7_harmonisation_lots('"+schemaProd+"','"+idcom+"');"
        cur.execute(req)
        conn.commit()
        val_progression=74        
        self.progressBar.setValue(val_progression)                 

        req="SELECT "+schemaProd+".__8_croisement_plu('"+schemaProd+"','"+idcom+"');"
        cur.execute(req)
        conn.commit()
        val_progression=76        
        self.progressBar.setValue(val_progression)                 
        
        req="SELECT "+schemaProd+".__9_typologie_prop('"+schemaProd+"','"+idcom+"');"
        cur.execute(req)
        conn.commit()
        val_progression=80    
        self.progressBar.setValue(val_progression)                 

        req="SELECT "+schemaProd+".__11_calcul_potentiel('"+schemaProd+"','"+idcom+"',"+surf_dense+");"
        cur.execute(req)
        conn.commit()
        val_progression=95        
        self.progressBar.setValue(val_progression) 

        req="SELECT "+schemaProd+".__12_tab_synthese('"+schemaProd+"','"+idcom+"');"
        cur.execute(req)
        conn.commit()
        val_progression=100    
        self.progressBar.setValue(val_progression)     

    #Affichage des couches SIG, création du fichier GPKG qui contient les couches produites et sauvegarde dans un fichier projet QGIS
    def productionCarte(self,idcom,dossierSortie,schemaProd,com):

        # Récupération des paramètres de connexion au serveur PG
        conn = psycopg2.connect(self.ConnectServer())
        cur = conn.cursor()
        
        QgsProject.instance().clear()
        QgsProject.instance().setCrs(QgsCoordinateReferenceSystem(2154))
        root = QgsProject.instance().layerTreeRoot()
        root.addGroup("Gisements fonciers "+idcom)
        parent = root.findGroup("Gisements fonciers "+idcom)

        AdrServPG=self.lineAdrServ.text()
        port=self.linePortServ.text()
        user=self.lineUserServ.text()
        mdp=self.lineMdpServ.text()
        NomBD=self.lineBaseDonnees.text()        
        
        uriPG = QgsDataSourceUri()
        uriPG.setConnection(AdrServPG,port,NomBD,user,mdp)
        GpName =dossierSortie+"/gisements_fonciers_"+idcom+".gpkg"
        for couche in ('synth_plu','synth_typo_prop','synth_potentiel_logt','plu','tup','envurb','foncier_mutable','bati','route','com'):

            if "synth" in couche:
                uriPG.setDataSource(schemaProd,"gf_"+couche+"_"+idcom,None)             
            else:
                uriPG.setDataSource(schemaProd,"gf_"+couche+"_"+idcom,"geom")

            layer_gf=QgsVectorLayer(uriPG.uri(),couche+"_"+idcom,"postgres")
            
            #Sauvegarde des indicateurs au format gpkg
            context = QgsProject.instance().transformContext()
            options = QgsVectorFileWriter.SaveVectorOptions()
            if os.path.isfile(GpName):
                options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
            options.layerName = layer_gf.name()
            options.fileEncoding = layer_gf.dataProvider().encoding()
            options.driverName = "GPKG"
            QgsVectorFileWriter.writeAsVectorFormatV2(layer_gf, GpName, context, options)

            QgsProject.instance().addMapLayer(layer_gf, False)            
            parent.addLayer(layer_gf)
            
        QgsProject.instance().clear()
        QgsProject.instance().setCrs(QgsCoordinateReferenceSystem(2154))
        canvas = iface.mapCanvas()
        canvas.show()
        #Chargement des couches GPKG        
        #GpName2=chemin+"/indicateurs.gpkg"
        for couche in ('synth_plu','synth_typo_prop','synth_potentiel_logt','plu','tup','envurb','foncier_mutable','bati','route','com'):
            gpkg_layer = GpName + "|layername="+couche+"_"+idcom
            vlayer = QgsVectorLayer(gpkg_layer, couche, "ogr")
            QgsProject.instance().addMapLayer(vlayer)
            if "synth" not in couche:
                vlayer.loadNamedStyle(os.path.dirname(__file__)+"/qgis/"+couche+".qml")
            if couche=='com':
                canvas.setExtent(vlayer.extent())       
                canvas.refresh()
        QgsProject.instance().write(dossierSortie+"/proj_"+idcom+".qgs")

        # création des couches agrégées (foncier mutable et tableaux de synthèse)
        dernier_com=idcom
        if len(com)>1:
            if self.initialisation_couches_agg:
                for couche in ('synth_plu','synth_typo_prop','synth_potentiel_logt','foncier_mutable'):                
                    req="DROP TABLE IF EXISTS "+schemaProd+".gf_"+couche+"_agg CASCADE;"                    
                    cur.execute(req)
                    conn.commit()
                    req="CREATE TABLE "+schemaProd+".gf_"+couche+"_agg AS SELECT * FROM "+schemaProd+".gf_"+couche+"_"+str(dernier_com)+" limit 0"                    
                    cur.execute(req)
                    conn.commit()                                  
                self.initialisation_couches_agg = False
                
            for couche in ('synth_plu','synth_typo_prop','synth_potentiel_logt','foncier_mutable'):                    
                req="ALTER TABLE "+schemaProd+".gf_"+couche+"_"+str(idcom)+" INHERIT "+schemaProd+".gf_"+couche+"_agg ;"
                cur.execute(req)
                conn.commit()                   

            GpName2 =dossierSortie+"/gisements_fonciers_agg.gpkg"
            for couche in ('synth_plu_agg','synth_typo_prop_agg','synth_potentiel_logt_agg','foncier_mutable_agg'):

                if "synth" in couche:
                    uriPG.setDataSource(schemaProd,"gf_"+couche,None)             
                else:
                    uriPG.setDataSource(schemaProd,"gf_"+couche,"geom")

                layer_gf=QgsVectorLayer(uriPG.uri(),couche,"postgres")
                
                #Sauvegarde des indicateurs au format gpkg
                context = QgsProject.instance().transformContext()
                options = QgsVectorFileWriter.SaveVectorOptions()
                if os.path.isfile(GpName2):
                    options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
                options.layerName = layer_gf.name()
                options.fileEncoding = layer_gf.dataProvider().encoding()
                options.driverName = "GPKG"
                QgsVectorFileWriter.writeAsVectorFormatV2(layer_gf, GpName2, context, options)
        conn.close()
                    
        
    # Fonction de vérification de la base PostgreSQL
    def CheckConnPG(self):
    
        # Récupération des paramètres de connexion au serveur PG
        AdrServPG=self.lineAdrServ.text()
        port=self.linePortServ.text()
        user=self.lineUserServ.text()
        mdp=self.lineMdpServ.text()
        NomBD=self.lineBaseDonnees.text()
        
        dossierSortie=self.lineDossierSortie.text()
        
        mDic_Init = self.returnParamServPG()
        self.mDic_Init = mDic_Init

        try:
            # Récupération des paramètres de connexion au serveur PG
             
            if NomBD=="":
                QMessageBox.warning(self,"Attention","Le champ base de données n'est pas renseigné !!!")
                pass
            else:
                conn = psycopg2.connect("dbname=postgres user=" + user + " password="+mdp+" host="+AdrServPG+" port ="+port+ " connect_timeout=1 ")
                cur = conn.cursor()
                cur.execute("SELECT version();")
                conn.close()

                try:
                    # Récupération des paramètres de connexion au serveur PG
                    conn = psycopg2.connect("dbname="+NomBD+" user=" + user + " password="+mdp+" host="+AdrServPG+" port ="+port+ " connect_timeout=1 ")
                    cur = conn.cursor()
                    cur.execute("SELECT * FROM public.spatial_ref_sys limit 1;")
                    schemas=[]
                    #Alimentation des combobox des schémas
                    reqsql="SELECT schema_name FROM information_schema.schemata where schema_name != 'information_schema' AND schema_name not like 'pg_%'"
                    cur.execute(reqsql)
                    lschemas=cur.fetchall()
                    conn.close()
                    #print(str(len(lschemas)))

                    for schema in lschemas:
                        schemas.append(schema[0])
                                        
                    self.comboBoxChoixSchemaData.clear()
                    self.comboBoxChoixSchemaData.addItems(schemas)                    
                    ind=self.comboBoxChoixSchemaData.findText(mDic_Init["schemaData"])                          
                    self.comboBoxChoixSchemaData.setCurrentIndex(ind)
            
                    self.comboBoxChoixSchemaBDTopo.clear()
                    self.comboBoxChoixSchemaBDTopo.addItems(schemas)
                    ind=self.comboBoxChoixSchemaBDTopo.findText(mDic_Init["schemaBDTopo"])
                    self.comboBoxChoixSchemaBDTopo.setCurrentIndex(ind) 

                    self.comboBoxChoixSchemaFFDep.clear()
                    self.comboBoxChoixSchemaFFDep.addItems(schemas)
                    ind=self.comboBoxChoixSchemaFFDep.findText(mDic_Init["schemaFFDep"])
                    self.comboBoxChoixSchemaFFDep.setCurrentIndex(ind) 

                    self.comboBoxChoixSchemaProd.clear()
                    self.comboBoxChoixSchemaProd.addItems(schemas)
                    ind=self.comboBoxChoixSchemaProd.findText(mDic_Init["schemaProd"])
                    self.comboBoxChoixSchemaProd.setCurrentIndex(ind)    

                    ind=self.comboBoxChoixTabPlu.findText(mDic_Init["tabPLU"])
                    self.comboBoxChoixTabPlu.setCurrentIndex(ind)                    
                    ind=self.comboBoxChoixTabEnvurb.findText(mDic_Init["tabEnvurb"])
                    self.comboBoxChoixTabEnvurb.setCurrentIndex(ind)                    
                    ind=self.comboBoxChoixTabCommune.findText(mDic_Init["tabCommune"])
                    self.comboBoxChoixTabCommune.setCurrentIndex(ind)
                    ind=self.comboBoxChoixTabBati.findText(mDic_Init["tabBati"])
                    self.comboBoxChoixTabBati.setCurrentIndex(ind)
                    ind=self.comboBoxChoixTabRoute.findText(mDic_Init["tabRoute"])
                    self.comboBoxChoixTabRoute.setCurrentIndex(ind)
                    ind=self.comboBoxChoixTabTup.findText(mDic_Init["tabTup"])
                    self.comboBoxChoixTabTup.setCurrentIndex(ind)                    
                    
                    # Alimentation de la combobox "tables data"
                    self.comboBoxChoixSchemaData.currentIndexChanged.connect(self.alimComboboxTablesData)  
                    # Alimentation de la combobox "tables BD Topo"
                    self.comboBoxChoixSchemaBDTopo.currentIndexChanged.connect(self.alimComboboxTablesBDTopo)
                    # Alimentation de la combobox "table TUP"
                    self.comboBoxChoixSchemaFFDep.currentIndexChanged.connect(self.alimComboboxTablesFFDep)
                    # Alimentation de la combobox "geom TUP"
                    self.comboBoxChoixTabTup.currentIndexChanged.connect(self.alimComboboxGeomTup)       
                    
                    #sauvegarde des noms des schémas dans le fichier QGIS.ini et copie des fonctions de traitement dans la base
                    self.QGISIniSave()                  
                    
                    QMessageBox.information(self,"Information","Connexion à la base "+NomBD+" réalisée avec succès !!!")
                    
                    
                except:
                    QMessageBox.critical(self,"Information","Les paramètres de connexion au serveur Postgresql sont incorrects !!! ")
                    
        except:
            QMessageBox.critical(self,"Information","Les paramètres de connexion au serveur Postgresql sont incorrects !!! ")            

    def ImportFonctionsScripts(self):
        
        # Récupération des paramètres de connexion au serveur PG
        conn = psycopg2.connect(self.ConnectServer())
        cur = conn.cursor()
        
        schemaProd = self.comboBoxChoixSchemaProd.currentText()
        
        if schemaProd=='':
            QMessageBox.critical(self,"Attention","Le schéma de production doit être défini !!! ")
        
        else:
            #Import des fonctions de calcul d'indicateurs dans la base
            dossier_fonction=os.path.dirname(__file__)+"/sql/"        
            fonctions=["fonction_1_envurb","fonction_1_envurb_exclusion","fonction_2_batiment_densite_urbaine","fonction_3_uf_non_bati_lot1","fonction_4_uf_espace_residuel_lots2et3","fonction_5_accessibilite","fonction_6_acces_indirect","fonction_7_harmonisation_lots","fonction_8_croisement_plu","fonction_9_typologie_prop","fonction_11_calcul_potentiel","fonction_12_tab_synthese"]
            for i in fonctions:
                # Copie des fonctions depuis le dossier sql/init vers le dossier sql
                with open(dossier_fonction+"init/__"+i+".sql", 'r') as file :
                    filedata = file.read()
                filedata = filedata.replace('public.', schemaProd+'.')
                with open(dossier_fonction+i+".sql", 'w') as file:
                    file.write(filedata)
                    
            # exécution des fonctions de traitement dans le schéma de production
            for j in fonctions:
                self.execFicSql(fichier=dossier_fonction+j+".sql",param='')                       
            
        self.QGISIniSave()
        conn.close()
        
        #Ajout table des départements GPKG
        self.importDeptEPCIGPKG()
        
        QMessageBox.information(self,"Information","La préparation de l'interface a été réalisée avec succès !!!")
        
    # Remplissage de la combobox tables Data
    def alimComboboxTablesData(self):
        
        # Récupération des paramètres de connexion au serveur PG
        conn = psycopg2.connect(self.ConnectServer())
        cur = conn.cursor()

        try:
            tables_names=[]
            reqsql="SELECT table_name FROM information_schema.tables WHERE table_schema = '" + self.comboBoxChoixSchemaData.currentText() + "' ORDER BY table_name;"
            cur.execute(reqsql)
            ltables=cur.fetchall()
            
            for table in ltables:
                tables_names.append(table[0])  
                
            self.comboBoxChoixTabPlu.clear()
            self.comboBoxChoixTabPlu.addItems(tables_names)
            self.comboBoxChoixTabPlu.setCurrentIndex(-1) 

            self.comboBoxChoixTabEnvurb.clear()
            self.comboBoxChoixTabEnvurb.addItems(tables_names)
            self.comboBoxChoixTabEnvurb.setCurrentIndex(-1) 
         
        except:
           pass       
        
        self.QGISIniSave()
        conn.close()
        
    # Remplissage de la combobox tables BD Topo
    def alimComboboxTablesBDTopo(self):
        
        # Récupération des paramètres de connexion au serveur PG
        conn = psycopg2.connect(self.ConnectServer())
        cur = conn.cursor()
        
        try:
            tables_names=[]
            reqsql="SELECT table_name FROM information_schema.tables WHERE table_schema = '" + self.comboBoxChoixSchemaBDTopo.currentText() + "' ORDER BY table_name;"
            cur.execute(reqsql)
            ltables=cur.fetchall()
            
            for table in ltables:
                tables_names.append(table[0])  
                
            self.comboBoxChoixTabCommune.clear()
            self.comboBoxChoixTabCommune.addItems(tables_names)
            self.comboBoxChoixTabCommune.setCurrentIndex(-1)

            self.comboBoxChoixTabBati.clear()
            self.comboBoxChoixTabBati.addItems(tables_names)
            self.comboBoxChoixTabBati.setCurrentIndex(-1)

            self.comboBoxChoixTabRoute.clear()
            self.comboBoxChoixTabRoute.addItems(tables_names)
            self.comboBoxChoixTabRoute.setCurrentIndex(-1)
            
        except:
           pass
           
        self.QGISIniSave()
        conn.close()

    def alimComboboxTablesFFDep(self):
        
        # Récupération des paramètres de connexion au serveur PG
        conn = psycopg2.connect(self.ConnectServer())
        cur = conn.cursor()

        try:
            tables_names=[]
            reqsql="SELECT table_name FROM information_schema.tables WHERE table_schema = '" + self.comboBoxChoixSchemaFFDep.currentText() + "' ORDER BY table_name;"
            cur.execute(reqsql)
            ltables=cur.fetchall()
            
            for table in ltables:
                tables_names.append(table[0])  
                
            self.comboBoxChoixTabTup.clear()
            self.comboBoxChoixTabTup.addItems(tables_names)
            self.comboBoxChoixTabTup.setCurrentIndex(-1) 
           
        except:
           pass       
        
        self.QGISIniSave()
        conn.close()

    def alimComboboxGeomTup(self):
        
        # Récupération des paramètres de connexion au serveur PG
        conn = psycopg2.connect(self.ConnectServer())
        cur = conn.cursor()

        try:
            geom_names=[]
            reqsql="SELECT column_name FROM information_schema.columns WHERE table_schema = '" + self.comboBoxChoixSchemaFFDep.currentText() + "' AND table_name= '" + self.comboBoxChoixTabTup.currentText() + "' AND data_type='USER-DEFINED' ;"
            cur.execute(reqsql)
            lgeom=cur.fetchall()
            
            for geom in lgeom:
                geom_names.append(geom[0])  
                
            self.comboBoxChoixGeomTup.clear()
            self.comboBoxChoixGeomTup.addItems(geom_names)
            self.comboBoxChoixGeomTup.setCurrentIndex(-1) 
           
        except:
           pass       
        
        self.QGISIniSave()
        conn.close()
        
    def QGISIniSave(self):
        
        #Mise à jour du fichier de configuration de la base PG (param_serveur.csv)
        mDicParam = {}
        mSettings = QgsSettings()
        mSettings.beginGroup("QGIS_FONCIER")
        mDicParam["AdrServPG"] = self.lineAdrServ.text()
        mDicParam["port"] = self.linePortServ.text()
        mDicParam["user"] = self.lineUserServ.text()
        mDicParam["mdp"] = self.lineMdpServ.text()
        mDicParam["NomBD"] = self.lineBaseDonnees.text()            
        mDicParam["schemaData"] = self.comboBoxChoixSchemaData.currentText()
        mDicParam["schemaBDTopo"] = self.comboBoxChoixSchemaBDTopo.currentText()
        mDicParam["schemaFFDep"] = self.comboBoxChoixSchemaFFDep.currentText()
        mDicParam["schemaProd"] = self.comboBoxChoixSchemaProd.currentText()
        mDicParam["TabPlu"] = self.comboBoxChoixTabPlu.currentText()
        mDicParam["TabEnvurb"] = self.comboBoxChoixTabEnvurb.currentText()
        mDicParam["TabCommune"] = self.comboBoxChoixTabCommune.currentText()
        mDicParam["TabBati"] = self.comboBoxChoixTabBati.currentText()
        mDicParam["TabRoute"] = self.comboBoxChoixTabRoute.currentText()
        mDicParam["TabTup"] = self.comboBoxChoixTabTup.currentText()
        mDicParam["geomTup"] = self.comboBoxChoixGeomTup.currentText()
    
        for key, value in mDicParam.items():
           mSettings.setValue(key, value)
        mSettings.endGroup()    
    
    def NettoyerBase(self):
        # Récupération des paramètres de connexion au serveur PG
        conn = psycopg2.connect(self.ConnectServer())
        cur = conn.cursor()
        
        reply = QMessageBox.question(self, 'Confirmation','Cette action supprimera toutes les tables générées par les traitements de calcul des gisements fonciers, ainsi que les fichiers log. Voulez-vous continuer ?', QMessageBox.Yes, QMessageBox.No)
        if reply == QMessageBox.Yes:
            try:
                schemaProd=self.comboBoxChoixSchemaProd.currentText()            
                cur = conn.cursor()
                
                reqsql = "select table_name from information_schema.tables where table_schema = '"+schemaProd+"' AND (table_name like 'gf_%')"
                cur.execute(reqsql)
                ltables=cur.fetchall()

                for table in ltables:
                    #print(table)
                    cur.execute("DROP TABLE IF EXISTS "+schemaProd+"."+table[0]+" CASCADE;")
                    conn.commit()
                conn.close()
                
                QMessageBox.information(self,"Information","La base de données a été nettoyée avec succès !!!")
            except:
                pass
        else:
            pass
                                
    def recupCheminFichierShp(self):
        try:
            global filename
            dlg_fichier = QFileDialog()
            dlg_fichier.setFileMode(QFileDialog.AnyFile)
            dlg_fichier.setNameFilter("shapefile (*.shp)")
            if dlg_fichier.exec():
                filename = ''.join(dlg_fichier.selectedFiles())
            return filename
        except:
            pass

    def recupCheminDossier(self):
        global folderpath
        dlg_folder = QFileDialog()
        folderpath = dlg_folder.getExistingDirectory(self, 'Select Folder')
        return folderpath
        
    def recupCheminFichierSql(self):
        global filename
        dlg_fichier = QFileDialog()
        dlg_fichier.setFileMode(QFileDialog.AnyFile)
        dlg_fichier.setNameFilter("SQL (*.sql)")
        if dlg_fichier.exec():
            filename = ''.join(dlg_fichier.selectedFiles())
        return filename
        
    #récupération des couches pour l'import des données
    def SelectionFicFF(self):
        try:
            self.recupCheminFichierSql()
            self.lineCheminFicFF.setText(filename)
        except:
            pass        

    def SelectionFicRoutes(self):
        try:
            self.recupCheminFichierShp()
            self.lineCheminFicRoutes.setText(filename)
        except:
            pass

    def SelectionFicCom(self):
        try:
            self.recupCheminFichierShp()
            self.lineCheminFicCom.setText(filename)
        except:
            pass

    def SelectionFicBat(self):
        try:
            self.recupCheminFichierShp()
            self.lineCheminFicBat.setText(filename)
        except:
            pass

    def SelectionFicPLU(self):
        try:
            self.recupCheminFichierShp()
            self.lineCheminFicPLU.setText(filename)
        except:
            pass

    def SelectionFicEnvUrb(self):
        try:
            self.recupCheminFichierShp()
            self.lineCheminFicEnvUrb.setText(filename)
        except:
            pass

    def SelectionFicExclusion(self):
        try:
            self.recupCheminFichierShp()
            self.lineCheminFicExclusion.setText(filename)
        except:
            pass        
        
    #importation des couches
    def ImportFF(self):
        # Récupération des paramètres de connexion au serveur PG
        conn = psycopg2.connect(self.ConnectServer())
        cur = conn.cursor()
        schemaFFDep = self.comboBoxChoixSchemaFFDep.currentText()        

        try:
            self.execFicSql(fichier=os.path.dirname(self.lineCheminFicFF.text())+'/ff_init.sql',param='')
            self.execFicSql(fichier=self.lineCheminFicFF.text(),param='')
            QMessageBox.information(self,"Information","L'import des fichiers fonciers a été réalisé avec succès.")
        except:
            QMessageBox.critical(None,"Erreur","L'import des fichiers fonciers a échoué ")      
        
    def ImportCom(self):
        self.ImportShape('commune')

    def ImportBat(self):
        self.ImportShape('batiment')

    def ImportRoutes(self):
        self.ImportShape('route')        

    def ImportPLU(self):
        self.ImportShape('PLU')
                    
    def ImportEnvUrb(self):
        self.ImportShape('envurb')

    def ImportShape(self,couche):
        # Récupération des paramètres de connexion au serveur PG
        conn = psycopg2.connect(self.ConnectServer())
        cur = conn.cursor()
        
        if couche == 'route' :            
            ficCouche = self.lineCheminFicRoutes.text()
            schema = self.comboBoxChoixSchemaBDTopo.currentText()
        elif couche == 'commune' :
            ficCouche = self.lineCheminFicCom.text()
            schema = self.comboBoxChoixSchemaBDTopo.currentText()
        elif couche == 'batiment' :
            ficCouche = self.lineCheminFicBat.text()
            schema = self.comboBoxChoixSchemaBDTopo.currentText()
        elif couche == 'PLU' :
            ficCouche = self.lineCheminFicPLU.text()
            schema = self.comboBoxChoixSchemaData.currentText()
        elif couche == 'envurb' :
            ficCouche = self.lineCheminFicEnvUrb.text()
            schema = self.comboBoxChoixSchemaData.currentText()            
        print(couche+ "  " + schema)
        nomCouche, ok = QInputDialog.getText(self, f"Nom de la couche", "Nom de la couche")
        if ok:
            if schema == "":
                QMessageBox.warning(self,"Attention","Aucun schéma n'est défini pour importer la couche !!!")
            elif nomCouche == "":
                QMessageBox.warning(self,"Attention","Veuillez renseigner un nom de couche avant de cliquer sur OK.")
            elif re.match('^[a-z][a-z0-9]\w*$', nomCouche):        
                try:
                    cur.execute("SELECT * FROM "+schema+"."+nomCouche+" limit 1;")
                    reply = QMessageBox.question(self, "Confirmation","La couche "+ couche +" de la BDTOPO sur ce département est déjà présente dans la base. Voulez-vous la remplacer ?", QMessageBox.Yes, QMessageBox.No)
                    if reply == QMessageBox.Yes:
                        cur.execute("DROP TABLE IF EXISTS "+schema+"."+nomCouche+";")
                        conn.commit()
                        conn.close()
                        self.ImportCoucheShp(ficCouche,nomCouche,schema)
                        QMessageBox.information(self,"Information","L'import de la couche "+ couche +" de la BDTOPO a été réalisé avec succès.")
                    else:
                        pass
                except:
                    self.ImportCoucheShp(ficCouche,nomCouche,schema)
                    QMessageBox.information(self,"Information","L'import de la couche "+ couche +" de la BDTOPO a été réalisé avec succès.")
            else:
                QMessageBox.warning(self,"Attention","Le nom de la couche doit commencer par une lettre et ne pas contenir de caractères spéciaux !!!")
        else:
            pass                

    #fonction d'import couche SHP dans Postgresql
    def ImportCoucheShp(self,chemin,nomCouche,schema):
        # Récupération des paramètres de connexion au serveur PG
        AdrServPG=self.lineAdrServ.text()
        port=self.linePortServ.text()
        user=self.lineUserServ.text()
        mdp=self.lineMdpServ.text()
        NomBD=self.lineBaseDonnees.text()

        str_rep_python = sys.base_prefix  # ajout MM
        str_rep_base = os.path.join(os.path.split(os.path.split(str_rep_python)[0])[0], 'bin')  # ajout MM

        os.environ['PGPASSWORD'] = mdp
        os.environ['PGCLIENTENCODING'] = 'UTF-8'
        ogr2ogrPath = os.path.join(str_rep_base, "ogr2ogr")  # modif MM      
        os.system(ogr2ogrPath +' -f PostgreSQL PG:"dbname='+ NomBD +' host='+ AdrServPG +' port='+ port +' user='+ user +' password='+ mdp +'" "'+ chemin +'" -lco GEOMETRY_NAME=geom -nlt PROMOTE_TO_MULTI -lco SPATIAL_INDEX=GIST -a_srs EPSG:2154 -nln '+schema+'.'+nomCouche+' -overwrite')        
        #print(ogr2ogrPath +' -f PostgreSQL PG:"dbname='+ NomBD +' host='+ AdrServPG +' port='+ port +' user='+ user +' password='+ mdp +'" "'+ chemin +'" -lco GEOMETRY_NAME=geom -nlt PROMOTE_TO_MULTI -lco SPATIAL_INDEX=GIST -a_srs EPSG:2154 -nln '+schema+'.'+nomCouche+' -overwrite')        

    def ImportExclusion(self):
        # Récupération des paramètres de connexion au serveur PG
        conn = psycopg2.connect(self.ConnectServer())
        cur = conn.cursor()
        schemaData = self.comboBoxChoixSchemaData.currentText()
        
        ficExclusion = self.lineCheminFicExclusion.text()
        nomExclusion = 'zones_exclusion'
        
        try:
            cur.execute("SELECT * FROM "+schemaData+"."+nomExclusion+" limit 1;")
            reply = QMessageBox.question(self, 'Confirmation','Une couche d''exclusion est déjà présente dans la base. Voulez-vous la remplacer ?', QMessageBox.Yes, QMessageBox.No)
            if reply == QMessageBox.Yes:
                cur.execute("DROP TABLE IF EXISTS "+schemaData+"."+nomExclusion)
                conn.commit()
                conn.close()
                self.ImportCoucheShp(self.lineCheminFicExclusion.text(),nomExclusion,schemaData)
                QMessageBox.information(self,"Information","L'import de la couche d''exclusion a été réalisé avec succès.")
            else:
                pass
        except:
            self.ImportCoucheShp(self.lineCheminFicExclusion.text(),nomExclusion,schemaData)
            QMessageBox.information(self,"Information","L'import de la couche d''exclusion a été réalisé avec succès.")

        
    def SelectionDossierSortie(self):
        dlg_fichier = QFileDialog()
        dlg_fichier.setFileMode(QFileDialog.Directory)
        if dlg_fichier.exec():
            filename = ''.join(dlg_fichier.selectedFiles())
        self.lineDossierSortie.setText(filename)
        ficParam = os.path.dirname(__file__)+"/csv/param_serveur.csv"
        #Mise à jour du fichier de configuration de la base PG (param_serveur.csv)
        
        AdrServPG=self.lineAdrServ.text()
        port=self.linePortServ.text()
        user=self.lineUserServ.text()
        mdp=self.lineMdpServ.text()
        NomBD=self.lineBaseDonnees.text()
        schemaProd=self.lineSchemaProd.text()
        schemaBDTopo=self.lineSchemaBDTopo.text()
        schemaFFDep=self.lineSchemaFFDep.text()
        
        f = open(ficParam, "w")
        f.write(AdrServPG+";"+port+";"+user+";"+mdp+";"+NomBD+";"+schemaData+";"+filename)
        f.close()
        
    # Fonction tout sélectionner ou désélectionner les communes
    def selectAll(self):
        if self.checkBoxSelectAll.isChecked()==1 :
            self.ListeCommunes.selectAll()
        else :
            self.ListeCommunes.clearSelection()
    
    # Fonction afficher la notice
    def AfficheNotice(self):
        #self.InitVariables()
        os.system(noticePath)

        
    # Fonction qui ferme l'interface
    def FermerInterface(self):
        self.close()
    
                
#**************************************************************
#*********************FONCTIONS GENERALES**********************
#**************************************************************
      
    def ConnectServer(self):
        AdrServPG=self.lineAdrServ.text()
        port=self.linePortServ.text()
        user=self.lineUserServ.text()
        mdp=self.lineMdpServ.text()
        NomBD=self.lineBaseDonnees.text()
    
        conn = "dbname="+NomBD+" user=" + user + " password="+mdp+" host="+AdrServPG+" port ="+port+ " connect_timeout=1 "
        return conn
        
    def SelectionDossierSortie(self):
        try:
            dlg_fichier = QFileDialog()
            dlg_fichier.setFileMode(QFileDialog.Directory)
            if dlg_fichier.exec():
                filename = ''.join(dlg_fichier.selectedFiles())
            self.lineDossierSortie.setText(filename)
            
            mDicParamServ = {}
            mSettings = QgsSettings()
            mSettings.beginGroup("QGIS_FONCIER")
            mSettings.setValue("dossierSortie", filename)           
            mSettings.endGroup()
        except:
            pass
    
    def returnParamServPG(self):
        mDicParamServ = {}
        mSettings = QgsSettings()
        mSettings.beginGroup("QGIS_FONCIER")
        
        #Paramètres serveur
        mDicParamServ["AdrServPG"] = mSettings.value("AdrServPG")
        mDicParamServ["port"] = mSettings.value("port")
        mDicParamServ["user"] = mSettings.value("user")
        mDicParamServ["mdp"] = mSettings.value("mdp")
        mDicParamServ["NomBD"] = mSettings.value("NomBD")        
        mDicParamServ["schemaProd"] = mSettings.value("schemaProd")
        mDicParamServ["schemaData"] = mSettings.value("schemaData")
        mDicParamServ["schemaBDTopo"] = mSettings.value("schemaBDTopo")
        mDicParamServ["schemaFFDep"] = mSettings.value("schemaFFDep")
        mDicParamServ["tabPLU"] = mSettings.value("tabPLU")
        mDicParamServ["tabEnvurb"] = mSettings.value("tabEnvurb")
        mDicParamServ["tabCommune"] = mSettings.value("tabCommune")
        mDicParamServ["tabBati"] = mSettings.value("tabBati")
        mDicParamServ["tabRoute"] = mSettings.value("tabRoute")
        mDicParamServ["tabTup"] = mSettings.value("tabTup")
        mDicParamServ["geomTup"] = mSettings.value("geomTup")        
        mDicParamServ["dossierSortie"] = mSettings.value("dossierSortie")
        
        #mDicParamServ[key] = mSettings.value(key)
        mSettings.endGroup()
        return mDicParamServ
